import{_ as A,c as e,o as a,f as i,gC as t,gD as s,gE as n,gF as c}from"./chunks/framework.BG74BkEs.js";const f=JSON.parse('{"title":"引擎架构","description":"","frontmatter":{},"headers":[],"relativePath":"zh/guide/engine-architecture.md","filePath":"zh/guide/engine-architecture.md","lastUpdated":1702156042000}'),l={name:"zh/guide/engine-architecture.md"},r=t+" 1x",o=s+" 1x",p=n+" 1x",d=c+" 1x",h=i('<h1 id="引擎架构" tabindex="-1">引擎架构 <a class="header-anchor vp-link" href="#引擎架构" aria-label="Permalink to &quot;引擎架构&quot;">​</a></h1><p>该引擎在设计时考虑了以下原则： <strong>场景独立性</strong> 和 <strong>面向服务</strong> 。</p><h2 id="独立于场景" tabindex="-1">独立于场景 <a class="header-anchor vp-link" href="#独立于场景" aria-label="Permalink to &quot;独立于场景&quot;">​</a></h2><p>虽然Unity设计推荐使用场景和预制体开发，但是在开发视觉小说时并不是很实际。</p><p>所有Naninovel系统并不直接和<a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.html" class="vp-link" target="_blank" rel="noreferrer">MonoBehaviour<span class="external-link-icon"> ↗</span></a> 关联，或依附于<a href="https://docs.unity3d.com/ScriptReference/Object.DontDestroyOnLoad.html" class="vp-link" target="_blank" rel="noreferrer">持久化<span class="external-link-icon"> ↗</span></a> 的 <a href="https://docs.unity3d.com/ScriptReference/GameObject.html" class="vp-link" target="_blank" rel="noreferrer">GameObject<span class="external-link-icon"> ↗</span></a> 。</p><div class="imgit-picture" style="display:flex;" data-imgit-container><picture style="width:100%;"><source srcset="'+r+'" type="image/avif"><source srcset="'+o+'"><img data-imgit-loadable alt="" width="308" height="210" loading="lazy" decoding="async"></picture><picture class="imgit-cover" style="width:100%;margin-left:-100%;"><source srcset="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUEAAAGobWV0YQAAAAAAAAAvaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAFBpY3R1cmVIYW5kbGVyAAAAAA5waXRtAAAAAAABAAAALGlsb2MAAAAARAAAAgABAAAAAQAAAdAAAAAnAAIAAAABAAAB9wAAABQAAABCaWluZgAAAAAAAgAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAGmluZmUCAAAAAAIAAGF2MDFBbHBoYQAAAAAaaXJlZgAAAAAAAAAOYXV4bAACAAEAAQAAANdpcHJwAAAAsWlwY28AAAAUaXNwZQAAAAAAAAAPAAAACgAAABBwaXhpAAAAAAMICAgAAAAMYXYxQ4EgAAAAAAATY29scm5jbHgAAgACAACAAAAAFGlzcGUAAAAAAAAADwAAAAoAAAAOcGl4aQAAAAABCAAAAAxhdjFDgQAcAAAAADhhdXhDAAAAAHVybjptcGVnOm1wZWdCOmNpY3A6c3lzdGVtczphdXhpbGlhcnk6YWxwaGEAAAAAHmlwbWEAAAAAAAAAAgABBAECgwQAAgQFBocIAAAAQ21kYXQKCDgM+lpAQ0AIMhsVwAAASEFAOBOODbrUETICmt8mlxByhc1zTNsKBRgM+lpUMgsVwAABIAABftfVkA==" type="image/avif"><img src="//:0" alt="cover" width="308" height="210" decoding="sync"></picture></div><p>下列根物体会根据运行环境使用：</p><ul><li><code>Naninovel&lt;Runtime&gt;</code> 运行时（发布后和编辑器模式play mode运行时）</li><li><code>Naninovel&lt;Editor&gt;</code> 编辑器模式（非play mode运行时）</li></ul><p>所有必需的游戏对象都是在引擎初始化时创建的，在应用启动时（在刚进入Play mode或启动发布包后）自动通过<a href="https://docs.unity3d.com/ScriptReference/RuntimeInitializeOnLoadMethodAttribute.html" class="vp-link" target="_blank" rel="noreferrer">RuntimeInitializeOnLoadMethod<span class="external-link-icon"> ↗</span></a> （运行时初始化onload方法）方法异步加载。你可以在配置菜单关闭 <code>Initialize On Application Load</code> 属性不在启动时初始化，在之后手动调用<code>RuntimeInitializer</code> (运行模式下) 或 <code>EditorInitializer</code> (编辑器模式下)来初始化。</p><div class="imgit-picture" style="display:flex;" data-imgit-container><picture style="width:100%;"><source srcset="'+p+'" type="image/avif"><source srcset="'+d+`"><img data-imgit-loadable alt="" width="720" height="291" loading="lazy" decoding="async"></picture><picture class="imgit-cover" style="width:100%;margin-left:-100%;"><source srcset="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUEAAAD5bWV0YQAAAAAAAAAvaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAFBpY3R1cmVIYW5kbGVyAAAAAA5waXRtAAAAAAABAAAAHmlsb2MAAAAARAAAAQABAAAAAQAAASEAAABTAAAAKGlpbmYAAAAAAAEAAAAaaW5mZQIAAAAAAQAAYXYwMUNvbG9yAAAAAGppcHJwAAAAS2lwY28AAAAUaXNwZQAAAAAAAAAkAAAADwAAABBwaXhpAAAAAAMICAgAAAAMYXYxQ4EgAAAAAAATY29scm5jbHgAAgACAACAAAAAF2lwbWEAAAAAAAAAAQABBAECgwQAAABbbWRhdAoIOBTj5pAQ0AIyRxXAAABIAEDLzlGhWgWgkcVP29Gpa6l+cMlWJsM0QpZf8by98+JDXE4QBjWfbd2bKFV5fsaW2Fk4i3bMaxM1QlwR+k90KhiA" type="image/avif"><img src="//:0" alt="cover" width="720" height="291" decoding="sync"></picture></div><p>因为初始化时异步进行的，在调用 <code>InitializeAsync()</code> 方法或订阅静态事件<code>Engine.OnInitialized</code> 时使用<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/" class="vp-link" target="_blank" rel="noreferrer">使用 Async 和 Await 的异步编程<span class="external-link-icon"> ↗</span></a></p><p>要完全禁用所有引擎系统并将其从内存中删除，请使用<code>Engine.Destroy()</code>静态方法。</p><h2 id="面向服务" tabindex="-1">面向服务 <a class="header-anchor vp-link" href="#面向服务" aria-label="Permalink to &quot;面向服务&quot;">​</a></h2><p>大多数引擎功能都是通过引擎服务实现的。引擎服务是IEngineService接口的实现，该接口会处理特定的功能，例如执行naninovel脚本，管理演出元素或保存加载游戏状态。</p><p>如果你想和引擎系统交互，大概率你是想使用某个引擎服务。你可以通过静态方法<code>Engine.GetService&lt;TService&gt;()</code>来获得相关引擎服务参考， <code>TService</code> 指你想要获取到的服务，比如，获取<code>IScriptPlayer</code> 服务：</p><div class="language-csharp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">csharp</span><pre class="shiki shiki-themes theme-light theme-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> player</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Engine.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GetService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IScriptPlayer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">player.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Stop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>你可以在<a href="/naninovel-docs/zh/guide/engine-services" class="vp-link">引擎服务</a> 中找到现在可用的服务列表，和关于如何重写/添加自定义服务的信息。</p><h2 id="高级概念" tabindex="-1">高级概念 <a class="header-anchor vp-link" href="#高级概念" aria-label="Permalink to &quot;高级概念&quot;">​</a></h2><p>下面的UML图说明了引擎体系结构的高级概念。请注意，图中的所有类和接口名称都在Naninovel命名空间下。例如，要引用 <code>Engine</code> 类，请使用 <code>Naninovel.Engine</code>或<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/namespaces/using-namespaces" class="vp-link" target="_blank" rel="noreferrer">包含名称空间<span class="external-link-icon"> ↗</span></a> 。</p><p><object class="engine-design-dark" data="/assets/img/engine-design-dark.svg" type="image/svg+xml"></object><object class="engine-design-light" data="/assets/img/engine-design-light.svg" type="image/svg+xml"></object></p>`,20),g=[h];function m(k,u,y,b,v,_){return a(),e("div",null,g)}const B=A(l,[["render",m]]);export{f as __pageData,B as default};
