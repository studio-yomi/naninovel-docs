import{_ as A,c as e,o as a,f as i,gC as t,gD as s,gE as n,gF as c}from"./chunks/framework.BG74BkEs.js";const f=JSON.parse('{"title":"エンジンアーキテクチャー","description":"","frontmatter":{},"headers":[],"relativePath":"ja/guide/engine-architecture.md","filePath":"ja/guide/engine-architecture.md","lastUpdated":1702156042000}'),l={name:"ja/guide/engine-architecture.md"},r=t+" 1x",o=s+" 1x",p=n+" 1x",d=c+" 1x",h=i('<h1 id="エンジンアーキテクチャー" tabindex="-1">エンジンアーキテクチャー <a class="header-anchor vp-link" href="#エンジンアーキテクチャー" aria-label="Permalink to &quot;エンジンアーキテクチャー&quot;">​</a></h1><p>このエンジンは次の原則を念頭に設計されています: <strong>シーンからの独立</strong> と <strong>サービス指向</strong>。</p><h2 id="シーンから独立" tabindex="-1">シーンから独立 <a class="header-anchor vp-link" href="#シーンから独立" aria-label="Permalink to &quot;シーンから独立&quot;">​</a></h2><p>Unityの設計はシーンとプレハブ構成を促進できますが、ビジュアルノベルを開発する場合はあまり実用的ではありません。</p><p>全ての Naninovel システムは、<a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.html" class="vp-link" target="_blank" rel="noreferrer">MonoBehaviour<span class="external-link-icon"> ↗</span></a> に直接バインドされていないか、<a href="https://docs.unity3d.com/ScriptReference/Object.DontDestroyOnLoad.html" class="vp-link" target="_blank" rel="noreferrer">persistent<span class="external-link-icon"> ↗</span></a> ルート <a href="https://docs.unity3d.com/ScriptReference/GameObject.html" class="vp-link" target="_blank" rel="noreferrer">ゲームオブジェクト<span class="external-link-icon"> ↗</span></a> に紐づいています。</p><div class="imgit-picture" style="display:flex;" data-imgit-container><picture style="width:100%;"><source srcset="'+r+'" type="image/avif"><source srcset="'+o+'"><img data-imgit-loadable alt="" width="308" height="210" loading="lazy" decoding="async"></picture><picture class="imgit-cover" style="width:100%;margin-left:-100%;"><source srcset="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUEAAAGobWV0YQAAAAAAAAAvaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAFBpY3R1cmVIYW5kbGVyAAAAAA5waXRtAAAAAAABAAAALGlsb2MAAAAARAAAAgABAAAAAQAAAdAAAAAnAAIAAAABAAAB9wAAABQAAABCaWluZgAAAAAAAgAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAGmluZmUCAAAAAAIAAGF2MDFBbHBoYQAAAAAaaXJlZgAAAAAAAAAOYXV4bAACAAEAAQAAANdpcHJwAAAAsWlwY28AAAAUaXNwZQAAAAAAAAAPAAAACgAAABBwaXhpAAAAAAMICAgAAAAMYXYxQ4EgAAAAAAATY29scm5jbHgAAgACAACAAAAAFGlzcGUAAAAAAAAADwAAAAoAAAAOcGl4aQAAAAABCAAAAAxhdjFDgQAcAAAAADhhdXhDAAAAAHVybjptcGVnOm1wZWdCOmNpY3A6c3lzdGVtczphdXhpbGlhcnk6YWxwaGEAAAAAHmlwbWEAAAAAAAAAAgABBAECgwQAAgQFBocIAAAAQ21kYXQKCDgM+lpAQ0AIMhsVwAAASEFAOBOODbrUETICmt8mlxByhc1zTNsKBRgM+lpUMgsVwAABIAABftfVkA==" type="image/avif"><img src="//:0" alt="cover" width="308" height="210" decoding="sync"></picture></div><p>環境に応じて、次のルートオブジェクトが使用されます:</p><ul><li><code>Naninovel&lt;Runtime&gt;</code> ランタイム用 (ビルドとエディターのプレイモードで);</li><li><code>Naninovel&lt;Editor&gt;</code> エディター用 (プレイモード外で).</li></ul><p>必要なすべてのゲームオブジェクトは、エンジンの初期化時に作成されます。これは <a href="https://docs.unity3d.com/ScriptReference/RuntimeInitializeOnLoadMethodAttribute.html" class="vp-link" target="_blank" rel="noreferrer">RuntimeInitializeOnLoadMethod<span class="external-link-icon"> ↗</span></a> を介して、アプリケーションの起動時に（プレイモードに入ったりビルドを実行した直後に）自動的かつ非同期に実行されます。 この動作を変更するには、エンジンの設定で <code>Initialize On Application Load</code> プロパティを無効にし、手動で <code>RuntimeInitializer</code> （ランタイムの場合）または <code>EditorInitializer</code>（エディターの場合）クラスを使用して初期化を呼び出します。</p><div class="imgit-picture" style="display:flex;" data-imgit-container><picture style="width:100%;"><source srcset="'+p+'" type="image/avif"><source srcset="'+d+`"><img data-imgit-loadable alt="" width="720" height="291" loading="lazy" decoding="async"></picture><picture class="imgit-cover" style="width:100%;margin-left:-100%;"><source srcset="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUEAAAD5bWV0YQAAAAAAAAAvaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAFBpY3R1cmVIYW5kbGVyAAAAAA5waXRtAAAAAAABAAAAHmlsb2MAAAAARAAAAQABAAAAAQAAASEAAABTAAAAKGlpbmYAAAAAAAEAAAAaaW5mZQIAAAAAAQAAYXYwMUNvbG9yAAAAAGppcHJwAAAAS2lwY28AAAAUaXNwZQAAAAAAAAAkAAAADwAAABBwaXhpAAAAAAMICAgAAAAMYXYxQ4EgAAAAAAATY29scm5jbHgAAgACAACAAAAAF2lwbWEAAAAAAAAAAQABBAECgwQAAABbbWRhdAoIOBTj5pAQ0AIyRxXAAABIAEDLzlGhWgWgkcVP29Gpa6l+cMlWJsM0QpZf8by98+JDXE4QBjWfbd2bKFV5fsaW2Fk4i3bMaxM1QlwR+k90KhiA" type="image/avif"><img src="//:0" alt="cover" width="720" height="291" decoding="sync"></picture></div><p>初期化プロセスは非同期なので、 <code>InitializeAsync()</code> メソッドを呼び出すときに <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/" class="vp-link" target="_blank" rel="noreferrer">async-await approach<span class="external-link-icon"> ↗</span></a> を使用するか、静的な <code>Engine.OnInitialized</code> イベントをサブスクライブします。</p><p>すべてのエンジンシステムを完全に無効にしてメモリから削除するには、静的メソッド <code>Engine.Destroy()</code> を使用します。</p><h2 id="サービス指向" tabindex="-1">サービス指向 <a class="header-anchor vp-link" href="#サービス指向" aria-label="Permalink to &quot;サービス指向&quot;">​</a></h2><p>エンジン機能のほとんどは、エンジンサービスを介して実装されます。 エンジンサービスは <code>IEngineService</code> インターフェースの実装であり、naninovelスクリプトの実行、アクターの管理、ゲームのセーブロードなど、特定のジョブを処理します。</p><p>エンジンシステムとやり取りする場合は、エンジンサービスを使用することをお勧めします。エンジンサービスへの参照は、静的メソッド <code>Engine.GetService&lt;TService&gt;()</code> で取得できます。ここで <code>TService</code> は、参照するサービスのタイプ（インターフェース）です。 たとえば、 <code>IScriptPlayer</code> サービスを取得するには:</p><div class="language-csharp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">csharp</span><pre class="shiki shiki-themes theme-light theme-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> player</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Engine.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GetService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IScriptPlayer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">player.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Stop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p><a href="/naninovel-docs/ja/guide/engine-services" class="vp-link">エンジンサービスガイド</a> で、現在利用可能なすべてのエンジンサービスのリストと、カスタムサービスを上書き/追加する方法を見ることができます。</p><h2 id="high-level-concept" tabindex="-1">High-Level Concept <a class="header-anchor vp-link" href="#high-level-concept" aria-label="Permalink to &quot;High-Level Concept&quot;">​</a></h2><p>次のUML図は、エンジンアーキテクチャの高レベルの概念を示しています。図のすべてのクラスとインターフェースの名前は <code>Naninovel</code> ネームスペース以下で整理されています。たとえば <code>Engine</code> クラスを参照するには <code>Naninovel.Engine</code> または<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/namespaces/using-namespaces" class="vp-link" target="_blank" rel="noreferrer">ネームスペースを含めて<span class="external-link-icon"> ↗</span></a> ください。</p><p><object class="engine-design-dark" data="/assets/img/engine-design-dark.svg" type="image/svg+xml"></object><object class="engine-design-light" data="/assets/img/engine-design-light.svg" type="image/svg+xml"></object></p>`,20),g=[h];function m(k,u,v,b,y,_){return a(),e("div",null,g)}const B=A(l,[["render",m]]);export{f as __pageData,B as default};
